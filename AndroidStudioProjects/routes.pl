use strict;
use Math::Trig 'great_circle_distance';

my @r1 = (
38.930462,  -104.725314,   # Home
38.930459,  -104.725328, 
38.930432,  -104.725365, 
38.930427,  -104.725376, 
38.930401,  -104.725426, 
38.930365,  -104.725468, 
38.930355,  -104.725502, 
38.930317,  -104.725556, 
38.930282,  -104.725614, 
38.93026,  -104.725687, 
38.930212,  -104.72577, 
38.930185,  -104.72582, 
38.930147,  -104.725896, 
38.930121,  -104.725965, 
38.93007,  -104.726035, 
38.930042,  -104.726079, 
38.930049,  -104.726155, 
38.930042,  -104.726228, 
38.930037,  -104.726292, 
38.930033,  -104.726345, 
38.93003,  -104.726429, 
38.930036,  -104.72653, 
38.930062,  -104.726576, 
38.930097,  -104.726655, 
38.930106,  -104.72671,   # 1/2 Entry
38.930115,  -104.726785, 
38.930149,  -104.726883, 
38.930177,  -104.72696, 
38.930261,  -104.726964, 
38.930309,  -104.726978, 
38.930366,  -104.726935,   # 1/3 Entry
38.930401,  -104.72699, 
38.930408,  -104.727059, 
38.930437,  -104.727019, 
38.930464,  -104.72701, 
38.930503,  -104.727004, 
38.930529,  -104.726958, 
38.930542,  -104.726898, 
38.930567,  -104.726853, 
38.930593,  -104.726805, 
38.930625,  -104.726724, 
38.930659,  -104.726638, 
38.930701,  -104.726585, 
38.930769,  -104.726457, 
38.930811,  -104.726374, 
38.930849,  -104.726295, 
38.930884,  -104.726242, 
38.93092,  -104.726166, 
38.93097,  -104.726103, 
38.93102,  -104.726067, 
38.931069,  -104.726063, 
38.931125,  -104.726083, 
38.931188,  -104.726108, 
38.931238,  -104.726129, 
38.931283,  -104.726162, 
38.931323,  -104.726197  # Lower Approach


);

my @r2 = (
38.932177,  -104.724792,   # <= Upper Approach
38.93218,  -104.724719, 
38.932152,  -104.72465, 
38.932134,  -104.724573, 
38.932054,  -104.724554, 
38.932001,  -104.724506, 
38.93194,  -104.724456, 
38.931875,  -104.724396, 
38.931812,  -104.72435, 
38.931764,  -104.724303, 
38.931689,  -104.724265, 
38.931646,  -104.724232, 
38.931571,  -104.724192,  # 1/3 Upper Entry
38.931518,  -104.724168, 
38.931454,  -104.724135, 
38.931375,  -104.72413, 
38.931296,  -104.724123, 
38.931238,  -104.72414, 
38.931185,  -104.724138,  # 1/2 Upper Entry
38.931145,  -104.724134, 
38.931097,  -104.72415, 
38.931058,  -104.724162, 
38.931029,  -104.724216, 
38.930985,  -104.724269, 
38.930973,  -104.724346, 
38.930958,  -104.72441, 
38.93092,  -104.724485, 
38.930888,  -104.724557, 
38.930858,  -104.724637, 
38.930821,  -104.72472, 
38.930775,  -104.724791, 
38.93075,  -104.724869, 
38.930705,  -104.724951, 
38.930661,  -104.725019, 
38.930638,  -104.725086, 
38.930602,  -104.72515, 
38.930586,  -104.725194, 
38.930564,  -104.725214, 
38.930554,  -104.725227, 
38.93054,  -104.72521, 
38.930527,  -104.725199, 
38.930515,  -104.725184, 
38.930517,  -104.725173, 
38.930507,  -104.725167, 
38.930512,  -104.725137, 
38.930488,  -104.725136, 
38.930486,  -104.725142, 
38.930477,  -104.72514, 
38.930471,  -104.725137, 
38.930468,  -104.725138, 
38.930472,  -104.72514, 
38.930471,  -104.725142, 
38.930472,  -104.725143, 
38.930474,  -104.725144, 
38.930476,  -104.725146, 
38.930477,  -104.725146, 
38.930476,  -104.725147, 
38.930476,  -104.725149, 
38.930475,  -104.725151, 
38.930474,  -104.725152, 
38.930474,  -104.725153, 
38.930474,  -104.725153, 
38.930474,  -104.725153, 
38.930473,  -104.725153, 
38.930473,  -104.725153, 
38.930473,  -104.725153, 
38.930473,  -104.725153, 
38.930473,  -104.725154, 
38.930474,  -104.725154, 
38.930474,  -104.725154   # Home
);

my @r3 = (
38.931358,  -104.726228,   # <= Bridle Pass Lower Entry
38.931387,  -104.726242, 
38.931405,  -104.726258, 
38.931424,  -104.726286, 
38.931453,  -104.726272, 
38.931508,  -104.7262, 
38.931549,  -104.72612, 
38.931585,  -104.726041, 
38.93162,  -104.725967, 
38.931667,  -104.725865, 
38.931705,  -104.725786, 
38.931749,  -104.725695, 
38.931798,  -104.725599, 
38.931848,  -104.725495, 
38.931921,  -104.725365, 
38.931975,  -104.725249, 
38.932036,  -104.725133, 
38.932087,  -104.725026, 
38.93213,  -104.724939, 
38.932169,  -104.724867   # <= Bridle Pass Upper Entry
);

#r1 home to lower
#r2 upper to home
#r3 lower to upper

# upper home cw loop
# r2 r1 r3

# upper home ccw loop
# backwards(r3) backwards(r1) backwards(r2)

# crunch(\@r1); // Using actual data now. No need to data fill.
# crunch(\@r2);
# crunch(\@r3);

#print "v" x 60 . "\n";
#path(@r1,backwards(@r2), backwards(@r3));
#path(@r1,backwards(@r2), backwards(@r3));
#path(@r3,@r2,backwards(@r1));
#path(@r3,@r2,backwards(@r1));
path(@r2, @r1, @r3, backwards(@r3), backwards(@r1), backwards(@r2));

sub path {
  my @data = @_;
  crunch(\@data);
  my @lat = ();
  my @lon = ();
  my @acc = ();
  for my $ndx (0 .. $#data) {
    last if ($ndx * 2 > $#data);
    push @lat, $data[$ndx * 2];
    push @lon, $data[$ndx * 2 + 1];
    push @acc, (rand(1) + 3.0);
  }
  print "public static final double[] WAYPOINTS_LAT = {\n";
  for my $ndx (0 .. $#lat) {
    print $lat[$ndx];
    if($ndx < $#lat) {
      print ",\n";
    } else {
      print "};\n\n";
    }
  }
  print "public static final double[] WAYPOINTS_LNG = {\n";
  for my $ndx (0 .. $#lon) {
    print $lon[$ndx];
    if($ndx < $#lon) {
      print ",\n";
    } else {
      print "};\n\n";
    }
  }
  print "public static final float[] WAYPOINTS_ACCURACY = {\n";
  for my $ndx (0 .. $#acc) {
    print $acc[$ndx]."f";
    if($ndx < $#acc) {
      print ",\n";
    } else {
      print "};\n\n";
    }
  }
}

sub backwards {
  my @data = @_;
  my @newdata = ();
  for my $x (0 .. $#data) {
    my $nlat = $x * 2;
    my $nlon = $x * 2 + 1;
    last if($nlon >= $#data);
    unshift @newdata, ($data[$nlat],$data[$nlon]);
  }
  return @newdata;
}

#Lat/Lon to rad
sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }

sub crunch {
  my $ary = shift;
  my @data = @$ary;
  my $again = 1;
  while($again) {
    my @tmp = ();
    for my $x (0 .. $#data) {
      my $nlat1 = $x * 2;
      my $nlon1 = $x * 2 + 1;
      my $nlat2 = ($x + 1) * 2;
      my $nlon2 = ($x + 1) * 2 + 1;
      push @tmp, ($data[$nlat1],$data[$nlon1]);
      last if($nlon2 > $#data);
#      print $data[$nlat1]."\t".$data[$nlon1]."\t\t";
#      print $data[$nlat2]."\t".$data[$nlon2]."\t\t";
      my $dist = haversine_m($data[$nlat1],$data[$nlon1],$data[$nlat2],$data[$nlon2]);
#      print $dist."\n";
      if ($dist > 40) {
        my $tlat = ($data[$nlat1] + $data[$nlat2])/2.0;
        my $tlon = ($data[$nlon1] + $data[$nlon2])/2.0;
#        print "\t\tPushing :\t".$tlat."\t".$tlon."\n";
        push @tmp, ($tlat, $tlon);
      }
    }
    if($#tmp == $#data) {
      $again = 0;
    } else {
#      print "=" x 60 . "\n";
      @data = @tmp;
    }
  }
  @$ary = @data;
}

sub haversine_m
{
  my ($lat1, $long1, $lat2, $long2) = @_;
  my $d2r = Math::Trig::pi/180.0;
  my $dlong = ($long2 - $long1) * $d2r;
  my $dlat = ($lat2 - $lat1) * $d2r;
  my $a = (sin($dlat/2.0) ** 2) + cos($lat1*$d2r) * cos($lat2*$d2r) * (sin($dlong/2.0) ** 2);
  my $c = 2 * atan2(sqrt($a), sqrt(1-$a));
  my $d = 6367 * $c;
  return $d*1000;
}
